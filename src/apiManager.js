// API Manager: rotate keys, fallback, rate-limit wait (15s), emit status
import * as Pollinations from './api/pollinations.js';

export class ApiManager {
  constructor(){
    // keys = array of {provider:'pollinations'|'openai'|'claude', key:'...'}
    this.keys = JSON.parse(localStorage.getItem('mrg_api_keys')||'[]');
    this.idx = 0;
    this.lockUntil = 0;
    this.statusCb = null;
  }
  setStatus(s){ if(this.statusCb) this.statusCb(s); }
  onStatus(cb){ this.statusCb = cb; }
  addKeys(arr){
    this.keys = arr;
    localStorage.setItem('mrg_api_keys', JSON.stringify(this.keys));
  }
  async request(provider, input, opts={}){
    while(true){
      if(Date.now() < this.lockUntil){
        this.setStatus('Menunggu ' + Math.ceil((this.lockUntil-Date.now())/1000) + ' detik sebelum mencoba kembali...');
        await this._sleep(1000);
        continue;
      }
      const keyObj = this._currentKeyForProvider(provider);
      if(!keyObj){
        this.setStatus('Tidak ada API key untuk provider ' + provider + '. Menunggu 15 detik...');
        await this._waitAndUnlock(15000);
        continue;
      }
      this.setStatus('MrG AI sedang berpikir dan mengatur jalur pemrosesanâ€¦');
      try{
        const res = await this._doRequest(provider, keyObj, input, opts);
        this.setStatus('Selesai');
        return res;
      }catch(err){
        console.warn('API error', err);
        if(err && err.isRateLimit){
          this._markKeyRateLimited(this._keyIndexFor(keyObj));
          const exhausted = this._allKeysExhaustedForProvider(provider);
          if(exhausted){
            await this._waitAndUnlock(15000);
          }else{
            this._rotate();
            this.setStatus('Rate-limited, mengganti API key dan mencoba lagi...');
            continue;
          }
        }else{
          this.setStatus('Terjadi error: ' + (err.message||'unknown'));
          throw err;
        }
      }
    }
  }

  _currentKeyForProvider(provider){
    if(!this.keys || this.keys.length===0) return null;
    for(let i=0;i<this.keys.length;i++){
      const idx = (this.idx + i) % this.keys.length;
      const k = this.keys[idx];
      if(k.provider === provider.split('-')[0] && !k.rateLimited){
        this.idx = idx;
        return k;
      }
    }
    return null;
  }
  _keyIndexFor(keyObj){
    return this.keys.findIndex(k=>k===keyObj);
  }
  _rotate(){ this.idx = (this.idx+1) % Math.max(1,this.keys.length); }
  _markKeyRateLimited(idx){ if(this.keys[idx]) this.keys[idx].rateLimited = true; localStorage.setItem('mrg_api_keys', JSON.stringify(this.keys)); }
  _allKeysExhaustedForProvider(provider){
    const p = provider.split('-')[0];
    return !this.keys.some(k=>k.provider===p && !k.rateLimited);
  }
  async _waitAndUnlock(ms){
    this.lockUntil = Date.now()+ms;
    this.setStatus('Menunggu ' + Math.ceil(ms/1000) + ' detik karena semua key terbatas...');
    await this._sleep(ms);
    (this.keys||[]).forEach(k=>k.rateLimited=false);
    localStorage.setItem('mrg_api_keys', JSON.stringify(this.keys));
    this.lockUntil = 0;
    this.setStatus('Mencoba ulang sekarang...');
  }
  _sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

  async _doRequest(provider, keyObj, input, opts){
    const key = keyObj.key;
    // Pollinations image
    if(provider === 'pollinations-image'){
      const img = await Pollinations.generateImage(input, key, opts);
      return { url: img.objectUrl, blob: img.blob, contentType: img.contentType };
    }
    // Pollinations chat (can be used for vision by sending messages with image_url)
    if(provider === 'pollinations-chat'){
      const data = await Pollinations.chatCompletion(input, key, opts);
      return data;
    }
    // Pollinations simple text
    if(provider === 'pollinations-text'){
      const data = await Pollinations.generateText(input, key, opts);
      return data;
    }
    // Fallback stubs for other providers (replace with real clients if needed)
    if(provider === 'claude'){
      await this._sleep(700);
      return { text: `Generated by claude (stub) for: ${input}` };
    }
    if(provider === 'openai'){
      await this._sleep(700);
      if (input && typeof input === 'string' && input.includes('extract_characters')) {
        return { characters: [{name:'Alya', base_desc:'Protagonist, curious'}, {name:'Bima', base_desc:'Sidekick, comedic'}] };
      }
      return { text: `OpenAI stub response for: ${input}` };
    }
    throw new Error('Unknown provider: '+provider);
  }
                }
